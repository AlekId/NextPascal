Структура TMethod-a:
  
	TMethod = record
		Code: Pointer;
		Data: TObject;  
	end;	

Сигнатура для вызова любого TMethod-a:
   
	 tmethod(self, param1, param2,...);
------------------------------------------------
1. Захват метода
	- capture STATIC metod
		TMethod.Code = const адрес метода
		TMethod.Data = self (TObject)
		
	- capture VIRTUAL method
		TMethod.Code = адрес виртуального метода полученного в рантайме по индексу
		TMethod.Data = self (TObject)
		
	- capture CLASS method	 
		TMethod.Code = const адрес метода
		TMethod.Data = self (TClass) (для корректной работы incref, decref - их необходимо реализовать для TClass, а refcount = -1)
		
	- capture VIRTUAL CLASS method	 
		TMethod.Code = адрес виртуального метода полученного в рантайме по индексу
		TMethod.Data = self (TClass) (для корректной работы incref, decref - их необходимо реализовать для TClass, а refcount = -1)		
		
------------------------------------------------  
2. Захват глобальной функции / анонимной функции
		TMethod.Code = const адрес функции переходника с сигнатурой adapter(self, param1, param2,...);
		TMethod.Data = nil	
		
------------------------------------------------		 
3. Захват замыкания 
		Замыкание - анонимный класс, с полями-захваченными переменными замыкания.
		Единственный метод замыкания содержит код замыкания
		 
		TMethod.Code = const адрес метода класса-замыкания (self, param1, param2,...);
		TMethod.Data = self замыкания (создается динамически)
		
------------------------------------------------
4. Захват вложенных (локальных процедур)

	любая вложенная процедура, использующая переменные/параметры внешней имеет следующую сигнатуру:
		nestedproc(s: context, param1, param2,...);
			
		где context - структура из используемых переменных/параметров внешней процедуры		
		при захвате такой процедуры создается-замыкание, где класс замыкания повторяет контекст вложенной процедуры
		
		TMethod.Code = const адрес вложенной процедуры
		TMethod.Data = self замыкания (создается динамически)	 